---
name: coding-design-pipeline
description: 코딩 요청을 받았을 때 모호함을 제거하고 구조화된 설계문을 생성하는 파이프라인. 새로운 기능 구현, 기존 기능 수정, 시스템 설계 요청에 사용.
---

# Coding Design Pipeline

## 목적
모호한 코딩 요청을 단계적으로 구체화하여 저성능 모델이 판단 없이 구현할 수 있는 설계문을 생성한다.

## 핵심 원칙
> **"더 이상 모호한 것이 없을 때까지 구체화한다"**

설계는 사람과 함께, 구현은 모델에 위임한다.

---

## [메타 규칙] 전 단계에 적용

- 해석이 여러 개면 → 제시하고 선택받기, 혼자 결정하지 않기
- 더 단순한 방법이 보이면 → 말하기
- 불명확하면 → 멈추고 질문하기

---

## 1단계: 도메인 파악

### 1-1. 도메인 용어 모호함 감지
요청에 사용된 용어가 구현 방식이 여러 개로 해석될 수 있는 경우:
- "레벨업", "쪽지", "파티초대" 같이 LLM이 보편적 패턴으로 채워버릴 수 있는 용어
- 사용자가 동작 방식을 명시하지 않은 경우

→ **모호함 있음**: 후보군 3개 제시 후 선택받기
→ **모호함 없음**: Q1~Q5 바로 진행

### 1-2. 도메인 질문
```
Q1: 이 시스템의 주체는 누구인가?
Q2: 그 주체가 수행하는 핵심 행위는?
Q3: 중심 객체는?
Q4: 그 객체의 상태는?
Q5: 그 객체에 가해지는 동작은?
```

### 1-3. 단계 완료 후 모호함 체크
→ 모호함 있으면 질문, 해소 후 2단계 진행

---

## 2단계: 필터링

1단계에서 확정된 객체/상태/동작으로 흐름 문장을 생성한다.

### 흐름 문장 3가지 관점
```
Q1: 상태변화 — "[객체]가 [동작]되면 [상태]로 변한다"
Q2: 도메인간 상호작용 — "[객체A]가 [객체B]를 [어떻게] 참조/영향을 주는가"
Q3: 가능한 동작 목록
```

### 이터레이션 분리
- 위 3가지에 포함되지 않는 것 → 다음 이터레이션 목록으로 분리
- 1차 이터레이션 = 흐름 문장이 end-to-end로 작동하는 최소 단위

### 단계 완료 후 모호함 체크
→ 모호함 있으면 질문, 해소 후 3단계 진행

---

## 3단계: 컨텍스트 파악

프로젝트 폴더를 스캔한다.

- **정보 있음** → 기존 구조 분석, 재사용 가능한 것 확인, 스타일 패턴 추출
- **정보 없음** → 신규 프로젝트로 간주, 4단계로 진행

---

## 4단계: 제약조건 + 검증

### 제약조건
1단계에서 해소된 비즈니스 규칙을 체크리스트로 정리
- 수치 제약 (응답시간 <=5ms 등)은 포함하지 않음 → 검증 불가
- 방향성 제약 (성능 최적화, 보안 고려 등)만 포함

### 완료 판단 기준
"[주체]가 [동작]했을 때 [결과]가 되면 완료"
형태로 검증 조건을 명시한다.

---

## 5단계: 설계문 생성

수집된 모든 정보를 `references/plan.md`로 저장한다.

### 설계문 형식
```markdown
## 도메인
- 주체: 
- 중심 객체: 
- 상태: 
- 동작: 

## 흐름 (1차 이터레이션)
- 상태변화: 
- 도메인간 상호작용: 
- 가능한 동작: 

## 컨텍스트
- 기술 스택: 
- 재사용 가능한 것: 
- 스타일 패턴: 

## 제약조건
- 비즈니스 규칙: 

## 검증
- 완료 기준: 

## 다음 이터레이션
- 
```

### 설계문 완성 후
설계문이 완성되면 **새로운 세션을 열고** 다음 메시지를 전송한다:

```
아래 설계문을 기반으로 구현하라. 설계문에 명시된 것만 구현하고, 
명시되지 않은 것은 추가하지 않는다.

[plan.md 전체 내용]
```

