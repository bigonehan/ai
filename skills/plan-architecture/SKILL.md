---
name: plan-architecture
description: "코드 구현 요청을 아키텍처 중심으로 처리하는 스킬."
---

# Plan Architecture

구현을 바로 시작하지 말고, 반드시 설계-구현 순서를 지킨다.

## Workflow

1. 요구사항 고정하기
- 입력, 출력, 제약조건, 성공 기준을 짧게 정리한다.
- 애매한 요구가 있으면 최소 질문으로 먼저 확정한다.
- 범위 밖 기능은 추가하지 않는다.

2. 아키텍처 계획 세우기
- 모듈 경계, 데이터 모델, 함수 책임, 호출 흐름을 먼저 설계한다.
- 아래 형식으로 계획을 만든 뒤 구현을 시작한다.

```text
[Architecture Plan]
- Goal:
- Inputs/Outputs:
- Modules:
- Data Model:
- Flow:
- Risks & Guards:
- Verification:
```

3. 함수형 구조 규칙 적용하기
- 모든 로직을 `ACTION`(부수효과)과 `CALC`(순수 계산)으로 분리한다.
- 전역 가변 상태를 직접 읽거나 쓰지 말고 인자/리턴으로 전달한다.
- 배열/객체 갱신은 Copy-on-Write(복사 -> 수정 -> 반환)만 사용한다.
- 인자 mutation(`push`, `splice`, `obj[key]=...`)을 금지한다.
- 외부 I/O, DOM, 로깅, 시간/랜덤은 액션 레이어로 격리한다.
- 액션 함수는 조립과 오케스트레이션만 수행하고 계산은 별도 함수로 분리한다.
- 분기/순서만 제어하는 함수 이름은 `flow_` 접두사를 사용한다.

4. 구현하기
- 계획의 모듈/함수 경계를 유지하며 필요한 코드만 작성한다.
- 기존 코드 스타일을 따르고 요청 범위를 넘어서는 추상화는 추가하지 않는다.
- 반복되는 저수준 패턴은 작고 재사용 가능한 헬퍼로 추출한다.

5. 검증하기
- 핵심 성공 기준을 체크하는 테스트 또는 실행 검증을 수행한다.
- 아래 체크리스트를 모두 통과해야 완료로 본다.

## Completion Checklist

- 요구사항/성공 기준이 코드 동작과 일치하는가?
- 계산 함수가 숨은 입력(전역/시간/랜덤/DOM)에 의존하지 않는가?
- 계산 함수가 숨은 출력(전역 변경/인자 mutation)을 만들지 않는가?
- 액션과 계산이 파일/함수 레벨에서 명확히 분리되었는가?
- 데이터 갱신이 Copy-on-Write로 구현되었는가?
- 불필요한 기능/설정/추상화를 추가하지 않았는가?
